const { Client, GatewayIntentBits, Collection, ActivityType } = require('discord.js');
const { Player } = require('discord-player');
const { SpotifyExtractor, SoundCloudExtractor } = require('@discord-player/extractor');
const fs = require('fs');
const path = require('path');
const chalk = require('chalk');
const Logger = require('./utils/advancedLogger');
const DebugMonitor = require('./utils/debugMonitor');
const MusicTracker = require('./utils/musicTracker');
const { initializeLeaderboardSystem } = require('./utils/leaderboardInitializer');
require('dotenv').config();

// Initialiser le syst√®me de logs avanc√©
const logger = new Logger();
const debugMonitor = new DebugMonitor();

// Cr√©er le dossier logs s'il n'existe pas
const logsDir = path.join(__dirname, '../logs');
if (!fs.existsSync(logsDir)) {
    fs.mkdirSync(logsDir, { recursive: true });
    console.log(chalk.green('üìÅ Dossier logs cr√©√©'));
}

// Configuration du client Discord
const client = new Client({
    intents: [
        GatewayIntentBits.Guilds,
        GatewayIntentBits.GuildMessages,
        GatewayIntentBits.GuildVoiceStates,
        GatewayIntentBits.MessageContent,
        GatewayIntentBits.GuildMembers
    ]
});

// Configuration du player musical (sans YouTube - utilise play-dl dans /play)
const player = new Player(client, {
    useLegacyFFmpeg: true,
    skipFFmpeg: false,
    connectionTimeout: 30000
});

// Configuration des extracteurs (sans YouTube - utilise play-dl dans /play)

try {
    if (process.env.SPOTIFY_CLIENT_ID && process.env.SPOTIFY_CLIENT_SECRET) {
        player.extractors.register(SpotifyExtractor, {
            clientId: process.env.SPOTIFY_CLIENT_ID,
            clientSecret: process.env.SPOTIFY_CLIENT_SECRET
        });
        logger.success('Extracteur Spotify enregistr√©');
    } else {
        logger.warning('Credentials Spotify manquants - Spotify d√©sactiv√©');
    }
} catch (error) {
    logger.warning('Erreur lors de l\'enregistrement de l\'extracteur Spotify:', error);
}

try {
    player.extractors.register(SoundCloudExtractor, {});
    logger.success('Extracteur SoundCloud enregistr√©');
} catch (error) {
    logger.warning('Erreur lors de l\'enregistrement de l\'extracteur SoundCloud:', error);
}

// Exporter le player pour les commandes (statusManager sera ajout√© plus tard)
module.exports = { player, client, logger, debugMonitor };

// Collection pour stocker les commandes
client.commands = new Collection();

// Chargement des commandes
const commandsPath = path.join(__dirname, 'commands');
const commandFolders = fs.readdirSync(commandsPath);

for (const folder of commandFolders) {
    const folderPath = path.join(commandsPath, folder);
    const commandFiles = fs.readdirSync(folderPath).filter(file => file.endsWith('.js'));
    
    for (const file of commandFiles) {
        const filePath = path.join(folderPath, file);
        const command = require(filePath);
        
        if ('data' in command && 'execute' in command) {
            client.commands.set(command.data.name, command);
            logger.success(`Commande charg√©e: ${command.data.name}`);
        } else {
            logger.error(`La commande ${filePath} n'a pas de propri√©t√© "data" ou "execute"`);
        }
    }
}

// Chargement des √©v√©nements
const eventsPath = path.join(__dirname, 'events');
const eventFiles = fs.readdirSync(eventsPath).filter(file => file.endsWith('.js'));

for (const file of eventFiles) {
    const filePath = path.join(eventsPath, file);
    const event = require(filePath);
    
    if (event.once) {
        client.once(event.name, (...args) => event.execute(...args));
    } else {
        client.on(event.name, (...args) => event.execute(...args));
    }
    logger.success(`√âv√©nement charg√©: ${event.name}`);
}

// Gestion des erreurs du player
player.events.on('error', (queue, error) => {
    logger.error(`Erreur dans la queue ${queue.guild.name}`, error, { guild: queue.guild.name });
    debugMonitor.logError(error, { type: 'player_queue', guild: queue.guild.name });
});

player.events.on('playerError', (queue, error) => {
    logger.error(`Erreur du player dans ${queue.guild.name}`, error, { guild: queue.guild.name });
    debugMonitor.logError(error, { type: 'player_error', guild: queue.guild.name });
});

// Gestion des erreurs des extracteurs
player.extractors.on('error', (extractor, error) => {
    logger.error(`Erreur de l'extracteur ${extractor.constructor.name}`, error, { extractor: extractor.constructor.name });
    debugMonitor.logError(error, { type: 'extractor_error', extractor: extractor.constructor.name });
});

// √âv√©nements pour d√©tecter les arr√™ts automatiques
player.events.on('playerStart', (queue, track) => {
    logger.success(`üéµ Lecture d√©marr√©e: ${track.title}`, { guild: queue.guild.name, track: track.title });
    // Mettre √† jour le statut imm√©diatement
    statusManager.updateStatus();
});

player.events.on('playerFinish', (queue, track) => {
    logger.info(`üèÅ Lecture termin√©e: ${track.title}`, { guild: queue.guild.name, track: track.title });
    // Mettre √† jour le statut imm√©diatement
    statusManager.updateStatus();
});

player.events.on('playerSkip', (queue, track) => {
    logger.info(`‚è≠Ô∏è Musique pass√©e: ${track.title}`, { guild: queue.guild.name, track: track.title });
    // Mettre √† jour le statut imm√©diatement
    statusManager.updateStatus();
});

player.events.on('emptyQueue', (queue) => {
    logger.warning(`‚ö†Ô∏è Queue vide dans ${queue.guild.name}`, { guild: queue.guild.name });
    // Mettre √† jour le statut imm√©diatement
    statusManager.updateStatus();
});

player.events.on('disconnect', (queue) => {
    logger.warning(`‚ö†Ô∏è D√©connexion du salon vocal dans ${queue.guild.name}`, { guild: queue.guild.name });
    // Mettre √† jour le statut imm√©diatement
    statusManager.updateStatus();
});

// √âv√©nements du player pour le monitoring
player.events.on('trackStart', (queue, track) => {
    logger.music(`Musique d√©marr√©e: ${track.title}`, { 
        guild: queue.guild.name, 
        track: track.title,
        author: track.author 
    });
});

player.events.on('trackEnd', (queue, track) => {
    logger.music(`Musique termin√©e: ${track.title}`, { 
        guild: queue.guild.name, 
        track: track.title 
    });
});

player.events.on('queueEnd', (queue) => {
    logger.music(`Queue termin√©e dans ${queue.guild.name}`, { guild: queue.guild.name });
});

// Syst√®me de gestion du statut dynamique
class BotStatusManager {
    constructor(client) {
        this.client = client;
        this.updateInterval = null;
        this.currentStatus = null;
    }

    start() {
        // Mettre √† jour le statut toutes les 10 secondes
        this.updateInterval = setInterval(() => {
            this.updateStatus();
        }, 10000);
        
        // Mise √† jour initiale
        this.updateStatus();
    }

    stop() {
        if (this.updateInterval) {
            clearInterval(this.updateInterval);
            this.updateInterval = null;
        }
    }

    async updateStatus() {
        try {
            const voiceManager = require('./utils/voiceManager');
            
            // Chercher dans tous les serveurs pour trouver une musique en cours
            let currentTrack = null;
            let radioStation = null;
            
            // D'abord v√©rifier le syst√®me de radio
            try {
                const radioModule = require('./commands/music/radio');
                if (radioModule.radioState && radioModule.radioState.currentStation && radioModule.radioState.connection) {
                    // V√©rifier que la connexion est vraiment active et non d√©truite
                    const connectionStatus = radioModule.radioState.connection.state.status;
                    if (connectionStatus === 'ready' || connectionStatus === 'connecting') {
                        logger.discord(`üìª Station radio active d√©tect√©e: ${radioModule.radioState.currentStation.name} (status: ${connectionStatus})`);
                        radioStation = radioModule.radioState.currentStation.name;
                    } else {
                        logger.discord(`üìª Radio configur√©e mais connexion inactive: ${connectionStatus}`);
                        // Si la connexion est d√©truite, r√©initialiser radioState
                        if (connectionStatus === 'destroyed' || connectionStatus === 'disconnected') {
                            console.log('üìª Connexion radio d√©truite, r√©initialisation de radioState');
                            radioModule.radioState.currentStation = null;
                            radioModule.radioState.connection = null;
                            radioModule.radioState.player = null;
                        }
                    }
                } else {
                    logger.discord(`üìª Aucune radio active d√©tect√©e`);
                }
            } catch (error) {
                logger.discord(`‚ùå Erreur lors de la v√©rification du syst√®me radio: ${error.message}`);
            }

            // Si pas de radio, v√©rifier les musiques YouTube
            if (!radioStation) {
                for (const guild of this.client.guilds.cache.values()) {
                    // V√©rifier si le bot est connect√© √† un salon vocal YouTube ET si la musique est vraiment en cours
                    if (voiceManager.isYouTubeConnected(guild) && voiceManager.isPlaying(guild)) {
                        logger.discord(`üîç V√©rification statut pour guild: ${guild.name} (musique en cours)`);
                        
                        // Essayer de r√©cup√©rer la musique en cours seulement si vraiment en cours
                        const track = voiceManager.getCurrentTrack(guild.id);
                        if (track && voiceManager.isPlaying(guild)) {
                            logger.discord(`üéµ Track trouv√©e ET en cours: ${track.title}`);
                            currentTrack = track;
                            break;
                        } else if (track) {
                            logger.discord(`‚ùå Track trouv√©e mais pas en cours: ${track.title}`);
                        } else {
                            logger.discord(`‚ùå Aucune track trouv√©e pour guild: ${guild.name}`);
                        }
                    } else if (voiceManager.isYouTubeConnected(guild)) {
                        logger.discord(`üîç Guild ${guild.name} connect√© YouTube mais pas de musique en cours`);
                    }
                }
            }
            
            let statusText = '/help pour les commandes';
            let statusType = ActivityType.Listening;
            
            if (currentTrack) {
                // Tronquer le titre si trop long (limite Discord: 128 caract√®res)
                const title = currentTrack.title.length > 50 ? 
                    currentTrack.title.substring(0, 47) + '...' : 
                    currentTrack.title;
                statusText = `üéµ ${title}`;
                statusType = ActivityType.Listening;
                logger.discord(`üéµ Statut musique: ${statusText}`);
            } else if (radioStation) {
                statusText = `üìª ${radioStation}`;
                statusType = ActivityType.Listening;
                logger.discord(`üìª Statut radio: ${statusText}`);
            } else {
                logger.discord(`üí§ Statut par d√©faut: ${statusText}`);
            }
            
            // Ne mettre √† jour que si le statut a chang√©
            if (statusText !== this.currentStatus) {
                this.client.user.setActivity(statusText, { type: statusType });
                this.currentStatus = statusText;
                logger.discord(`Statut mis √† jour: ${statusText}`);
            }
            
        } catch (error) {
            logger.error('Erreur lors de la mise √† jour du statut:', error);
        }
    }
}

// Initialiser le gestionnaire de statut
const statusManager = new BotStatusManager(client);

// Ajouter statusManager √† l'export apr√®s initialisation
module.exports.statusManager = statusManager;

// D√©marrer le syst√®me de monitoring
debugMonitor.startMonitoring();

// Connexion du bot
client.login(process.env.DISCORD_TOKEN).then(async () => {
    logger.success('üéµ Bot Discord Musical üï≤- ùòÆ connect√© avec succ√®s!');
    logger.discord(`Connect√© en tant que ${client.user.tag}`);
    logger.discord(`Servant ${client.guilds.cache.size} serveurs`);
    logger.discord(`Servant ${client.users.cache.size} utilisateurs`);
    
    // D√©marrer le gestionnaire de statut dynamique
    statusManager.start();
    
    // Initialiser le syst√®me de leaderboard complet
    try {
        await initializeLeaderboardSystem(client);
        logger.success('üìä Syst√®me de leaderboard complet initialis√©');
        
        // Initialiser le MusicTracker
        MusicTracker.startCleanup();
        logger.success('üéµ Syst√®me de tracking des musiques d√©marr√©');
        
        // Syst√®me de leaderboard compl√®tement initialis√©
        
    } catch (error) {
        logger.error('Erreur lors de l\'initialisation du syst√®me de leaderboard:', error);
    }
    
    // G√©n√©rer un rapport initial (D√âSACTIV√â URGENCE)
    // setTimeout(() => {
    //     const report = debugMonitor.generateReport();
    //     logger.info('Rapport de d√©marrage g√©n√©r√©', report);
    // }, 5000);
    
}).catch(error => {
    logger.error('Erreur de connexion Discord', error);
    debugMonitor.logError(error, { type: 'discord_connection' });
    process.exit(1);
});

// Gestion des erreurs non captur√©es
process.on('uncaughtException', (error) => {
    logger.error('Exception non captur√©e', error);
    debugMonitor.logError(error, { type: 'uncaught_exception' });
});

process.on('unhandledRejection', (reason, promise) => {
    logger.error('Promesse rejet√©e non g√©r√©e', reason, { promise: promise.toString() });
    debugMonitor.logError(reason, { type: 'unhandled_rejection', promise: promise.toString() });
});

// Arr√™t propre du bot
process.on('SIGINT', () => {
    logger.info('Signal SIGINT re√ßu, arr√™t du bot...');
    statusManager.stop();
    const { stopLeaderboardSystem } = require('./utils/leaderboardInitializer');
    stopLeaderboardSystem();
    debugMonitor.stopMonitoring();
    logger.stopCleanup();
    client.destroy();
    process.exit(0);
});

process.on('SIGTERM', () => {
    logger.info('Signal SIGTERM re√ßu, arr√™t du bot...');
    statusManager.stop();
    const { stopLeaderboardSystem } = require('./utils/leaderboardInitializer');
    stopLeaderboardSystem();
    debugMonitor.stopMonitoring();
    logger.stopCleanup();
    client.destroy();
    process.exit(0);
});
