const { SlashCommandBuilder, EmbedBuilder, ActionRowBuilder, ButtonBuilder, ButtonStyle, PermissionFlagsBits } = require('discord.js');
const { joinVoiceChannel, createAudioPlayer, createAudioResource, AudioPlayerStatus, VoiceConnectionStatus } = require('@discordjs/voice');
const { getVoiceConnection } = require('@discordjs/voice');
const Logger = require('../../utils/advancedLogger');
const LeaderboardTracker = require('../../utils/enhancedLeaderboardTracker');

// Cr√©er une instance du logger pour ce module
const logger = new Logger();

// Importation des stations organis√©es par pays
const { SIMPLIFIED_RADIO_STATIONS, SIMPLIFIED_CATEGORIES, ALL_RADIO_STATIONS, RADIO_CATEGORIES } = require('./radio/index');

// Fonction pour mettre √† jour le statut du bot
function updateBotStatus() {
    try {
        console.log('üîÑ Tentative de mise √† jour du statut du bot...');
        // R√©cup√©rer le gestionnaire de statut depuis index.js
        const { statusManager } = require('../../index');
        if (statusManager) {
            console.log('‚úÖ StatusManager trouv√©, mise √† jour du statut...');
            statusManager.updateStatus();
        } else {
            console.log('‚ùå StatusManager non trouv√©');
        }
    } catch (error) {
        console.log(`‚ùå Erreur lors de la mise √† jour du statut: ${error.message}`);
    }
}

// Utiliser les stations simplifi√©es par d√©faut
const RADIO_STATIONS = SIMPLIFIED_RADIO_STATIONS;

// √âtat global du bot radio
let radioState = {
    isLocked: false,
    currentStation: null,
    connection: null,
    player: null,
    lockedChannel: null,
    lockedBy: null,
    lockedAt: null
};

// Fonction pour cr√©er l'embed de navigation par pays et styles
function createCountryNavigationEmbed() {
    const embed = new EmbedBuilder()
        .setColor('#7289DA')
        .setTitle('üåç **NAVIGATION PAR PAYS & STYLES** üåç')
        .setDescription('üéµ **Choisissez un pays ou un style pour explorer ses stations de radio** üéµ\n\n' +
            'üá´üá∑ **France** ‚Ä¢ üá¨üáß **Royaume-Uni** ‚Ä¢ üá∫üá∏ **√âtats-Unis** ‚Ä¢ üá¶üá∫ **Australie** ‚Ä¢ üåç **Internet**\n' +
            'üé§ **Rap & Hip-Hop** ‚Ä¢ üéõÔ∏è **Techno & Electronic**')
        .setThumbnail('https://cdn.discordapp.com/attachments/1234567890123456789/1234567890123456789/world-icon.png')
        .setImage('https://cdn.discordapp.com/attachments/1234567890123456789/1234567890123456789/world-banner.png');

    // Afficher les statistiques par pays et styles
    const countryStats = [
        `üá´üá∑ **France:** ${RADIO_CATEGORIES['üá´üá∑ **RADIOS FRAN√áAISES**'].length} stations`,
        `üá¨üáß **Royaume-Uni:** ${RADIO_CATEGORIES['üá¨üáß **RADIOS BRITANNIQUES**'].length} stations`,
        `üá∫üá∏ **√âtats-Unis:** ${RADIO_CATEGORIES['üá∫üá∏ **RADIOS AM√âRICAINES**'].length} stations`,
        `üá¶üá∫ **Australie:** ${RADIO_CATEGORIES['üá¶üá∫ **RADIOS AUSTRALIENNES**'].length} stations`,
        `üåç **Internet:** ${RADIO_CATEGORIES['üåç **RADIOS INTERNET**'].length} stations`,
        `üé§ **Rap & Hip-Hop:** ${RADIO_CATEGORIES['üé§ **RAP & HIP-HOP**'].length} stations`,
        `üéõÔ∏è **Techno & Electronic:** ${RADIO_CATEGORIES['üéõÔ∏è **TECHNO & ELECTRONIC**'].length} stations`
    ];

    embed.addFields({
        name: 'üìä **STATISTIQUES PAR CAT√âGORIE**',
        value: countryStats.join('\n'),
        inline: false
    });

    embed.setFooter({ 
        text: `üåç Radio Bot ‚Ä¢ Navigation par Pays & Styles ‚Ä¢ ${new Date().toLocaleTimeString('fr-FR')}`,
        iconURL: 'https://cdn.discordapp.com/attachments/1234567890123456789/1234567890123456789/world-icon.png'
    });

    return embed;
}

// Fonction pour cr√©er l'embed des stations d'un pays
function createCountryStationsEmbed(countryKey, countryName, countryEmoji) {
    const stationIds = RADIO_CATEGORIES[countryKey];
    const stations = stationIds.map(id => ALL_RADIO_STATIONS[id]).filter(Boolean);
    
    const embed = new EmbedBuilder()
        .setColor('#7289DA')
        .setTitle(`${countryEmoji} **${countryName.toUpperCase()}** ${countryEmoji}`)
        .setDescription(`üéµ **Stations de radio de ${countryName}** üéµ\n\n` +
            `üìª **${stations.length} stations disponibles** ‚Ä¢ üéß **Qualit√© HD**`)
        .setThumbnail('https://cdn.discordapp.com/attachments/1234567890123456789/1234567890123456789/radio-icon.png')
        .setImage('https://cdn.discordapp.com/attachments/1234567890123456789/1234567890123456789/radio-banner.png');

    if (stations.length > 0) {
        let stationList = '';
        for (let index = 0; index < stations.length; index++) {
            const station = stations[index];
            const rank = index + 1;
            const stationEntry = `${rank}. ${station.emoji} **${station.name}**\n` +
                               `   üìù ${station.description}\n` +
                               `   üéµ Style: **${station.style}**\n\n`;
            
            // V√©rifier si l'ajout de cette station d√©passerait la limite de 1024 caract√®res
            if (stationList.length + stationEntry.length > 1000) {
                stationList += `... et ${stations.length - index} autres stations`;
                break;
            }
            stationList += stationEntry;
        }
        
        embed.addFields({
            name: `üìª **STATIONS DE ${countryName.toUpperCase()}**`,
            value: stationList,
            inline: false
        });
    }

    embed.setFooter({ 
        text: `${countryEmoji} Radio Bot ‚Ä¢ ${countryName} ‚Ä¢ ${new Date().toLocaleTimeString('fr-FR')}`,
        iconURL: 'https://cdn.discordapp.com/attachments/1234567890123456789/1234567890123456789/radio-icon.png'
    });

    return embed;
}

// Fonction pour cr√©er l'embed de s√©lection de radio
function createRadioSelectionEmbed() {
    const embed = new EmbedBuilder()
        .setColor('#7289DA')
        .setTitle('üìª **RADIO STATION SELECTOR** üìª')
        .setDescription('üéµ **Choisissez votre station de radio pr√©f√©r√©e** üéµ\n\n' +
            'üåç **Stations Internationales** ‚Ä¢ üé∂ **Styles Vari√©s** ‚Ä¢ üéß **Qualit√© HD**')
        .setThumbnail('https://cdn.discordapp.com/attachments/1234567890123456789/1234567890123456789/radio-icon.png')
        .setImage('https://cdn.discordapp.com/attachments/1234567890123456789/1234567890123456789/radio-banner.png');

    // Grouper les stations par cat√©gorie
    const categories = SIMPLIFIED_CATEGORIES;

    Object.entries(categories).forEach(([categoryName, stationIds]) => {
        let categoryText = '';
        stationIds.forEach(stationId => {
            const station = RADIO_STATIONS[stationId];
            categoryText += `${station.emoji} **${station.name}** - ${station.description}\n`;
        });
        
        embed.addFields({
            name: categoryName,
            value: categoryText,
            inline: false
        });
    });

    embed.setFooter({ 
        text: `üéß Radio Bot ‚Ä¢ ${new Date().toLocaleTimeString('fr-FR')} ‚Ä¢ Qualit√© HD ‚Ä¢ Streaming Live`,
        iconURL: 'https://cdn.discordapp.com/attachments/1234567890123456789/1234567890123456789/radio-icon.png'
    });

    return embed;
}

// Fonction pour cr√©er les boutons de navigation par pays et styles
function createCountryNavigationButtons() {
    const row1 = new ActionRowBuilder()
        .addComponents(
            new ButtonBuilder()
                .setCustomId('radio_country_france')
                .setLabel('France')
                .setStyle(ButtonStyle.Primary)
                .setEmoji('üá´üá∑'),
            new ButtonBuilder()
                .setCustomId('radio_country_britain')
                .setLabel('Royaume-Uni')
                .setStyle(ButtonStyle.Primary)
                .setEmoji('üá¨üáß'),
            new ButtonBuilder()
                .setCustomId('radio_country_america')
                .setLabel('√âtats-Unis')
                .setStyle(ButtonStyle.Primary)
                .setEmoji('üá∫üá∏'),
            new ButtonBuilder()
                .setCustomId('radio_country_australia')
                .setLabel('Australie')
                .setStyle(ButtonStyle.Primary)
                .setEmoji('üá¶üá∫'),
            new ButtonBuilder()
                .setCustomId('radio_country_internet')
                .setLabel('Internet')
                .setStyle(ButtonStyle.Secondary)
                .setEmoji('üåç')
        );
    
    const row2 = new ActionRowBuilder()
        .addComponents(
            new ButtonBuilder()
                .setCustomId('radio_country_rap')
                .setLabel('Rap & Hip-Hop')
                .setStyle(ButtonStyle.Success)
                .setEmoji('üé§'),
            new ButtonBuilder()
                .setCustomId('radio_country_techno')
                .setLabel('Techno & Electronic')
                .setStyle(ButtonStyle.Success)
                .setEmoji('üéõÔ∏è')
        );
    
    return [row1, row2];
}

// Fonction pour cr√©er les boutons de stations d'un pays
function createCountryStationButtons(countryKey) {
    const stationIds = RADIO_CATEGORIES[countryKey];
    const rows = [];
    
    // Cr√©er des rang√©es de boutons (max 5 par rang√©e)
    for (let i = 0; i < stationIds.length; i += 5) {
        const row = new ActionRowBuilder();
        const rowStations = stationIds.slice(i, i + 5);
        
        rowStations.forEach(stationId => {
            const station = ALL_RADIO_STATIONS[stationId];
            if (station) {
                row.addComponents(
                    new ButtonBuilder()
                        .setCustomId(`radio_${stationId}`)
                        .setLabel(station.name)
                        .setStyle(ButtonStyle.Secondary)
                        .setEmoji(station.emoji)
                );
            }
        });
        
        rows.push(row);
    }
    
    // Bouton retour pour revenir au menu des pays
    const backRow = new ActionRowBuilder()
        .addComponents(
            new ButtonBuilder()
                .setCustomId('radio_back_countries')
                .setLabel('Retour aux pays')
                .setStyle(ButtonStyle.Secondary)
                .setEmoji('üåç')
        );
    
    rows.push(backRow);
    
    return rows;
}

// Fonction pour cr√©er les boutons de s√©lection de radio
function createRadioButtons() {
    const rows = [];
    const stations = Object.entries(RADIO_STATIONS);
    
    // Cr√©er des rang√©es de boutons (max 5 par rang√©e)
    for (let i = 0; i < stations.length; i += 5) {
        const row = new ActionRowBuilder();
        const rowStations = stations.slice(i, i + 5);
        
        rowStations.forEach(([stationId, station]) => {
            row.addComponents(
                new ButtonBuilder()
                    .setCustomId(`radio_${stationId}`)
                    .setLabel(station.name)
                    .setStyle(ButtonStyle.Secondary)
                    .setEmoji(station.emoji)
            );
        });
        
        rows.push(row);
    }
    
    // Boutons de contr√¥le
    const controlRow = new ActionRowBuilder()
        .addComponents(
            new ButtonBuilder()
                .setCustomId('radio_stop')
                .setLabel('Arr√™ter')
                .setStyle(ButtonStyle.Danger)
                .setEmoji('‚èπÔ∏è'),
            new ButtonBuilder()
                .setCustomId('radio_lock')
                .setLabel('Verrouiller')
                .setStyle(ButtonStyle.Primary)
                .setEmoji('üîí'),
            new ButtonBuilder()
                .setCustomId('radio_unlock')
                .setLabel('D√©verrouiller')
                .setStyle(ButtonStyle.Success)
                .setEmoji('üîì'),
            new ButtonBuilder()
                .setCustomId('radio_status')
                .setLabel('Statut')
                .setStyle(ButtonStyle.Secondary)
                .setEmoji('üìä')
        );
    
    rows.push(controlRow);
    
    return rows;
}

// Fonction pour d√©marrer une station de radio
async function startRadioStation(interaction, stationId) {
    const station = ALL_RADIO_STATIONS[stationId];
    if (!station) {
        return interaction.editReply({
            content: '‚ùå Station de radio introuvable!'
        });
    }

    try {
        // V√©rifier si l'utilisateur est dans un salon vocal
        const member = interaction.member;
        if (!member.voice.channel) {
            return interaction.editReply({
                content: '‚ùå Vous devez √™tre dans un salon vocal pour utiliser cette commande!'
            });
        }

        const voiceChannel = member.voice.channel;

        // V√©rifier les permissions
        if (!voiceChannel.permissionsFor(interaction.guild.members.me).has(['Connect', 'Speak'])) {
            return interaction.editReply({
                content: '‚ùå Je n\'ai pas les permissions pour rejoindre ce salon vocal!'
            });
        }

        // Arr√™ter la radio actuelle si elle est en cours
        if (radioState.player || radioState.connection) {
            console.log('üìª Arr√™t de l\'ancienne radio pour en d√©marrer une nouvelle');
            if (radioState.player) {
                radioState.player.stop();
            }
            if (radioState.connection) {
                radioState.connection.destroy();
            }
            // R√©initialiser l'√©tat avant de d√©marrer la nouvelle radio
            radioState.currentStation = null;
            radioState.connection = null;
            radioState.player = null;
            // Mettre √† jour le statut imm√©diatement apr√®s l'arr√™t
            updateBotStatus();
        }

        // Cr√©er la connexion vocale
        const connection = joinVoiceChannel({
            channelId: voiceChannel.id,
            guildId: interaction.guild.id,
            adapterCreator: interaction.guild.voiceAdapterCreator,
        });

        // Cr√©er le lecteur audio
        const player = createAudioPlayer();
        const resource = createAudioResource(station.url);

        // Configurer les √©v√©nements
        player.on(AudioPlayerStatus.Playing, () => {
            logger.success(`üéµ Radio d√©marr√©e: ${station.name} dans ${voiceChannel.name}`);
            // D√©marrer le tracking radio pour le leaderboard
            LeaderboardTracker.updateRadioPlayTime(15);
            // Mettre √† jour le statut du bot
            updateBotStatus();
        });

        player.on(AudioPlayerStatus.Idle, () => {
            logger.warning(`‚ö†Ô∏è Radio en pause: ${station.name}`);
            // Mettre √† jour le statut du bot
            updateBotStatus();
        });

        player.on('error', (error) => {
            logger.error(`‚ùå Erreur radio: ${station.name}`, error);
            // Mettre √† jour le statut du bot
            updateBotStatus();
        });

        connection.on(VoiceConnectionStatus.Ready, () => {
            logger.success(`üîä Connexion radio √©tablie: ${station.name}`);
            // Mettre √† jour le statut du bot
            updateBotStatus();
        });

        connection.on(VoiceConnectionStatus.Disconnected, () => {
            logger.warning(`üîå Connexion radio perdue: ${station.name}`);
            // Mettre √† jour le statut du bot
            updateBotStatus();
        });

        // D√©marrer la lecture
        connection.subscribe(player);
        player.play(resource);

        // Mettre √† jour l'√©tat
        radioState.connection = connection;
        radioState.player = player;
        radioState.currentStation = station;
        radioState.lockedChannel = voiceChannel;

        // Mettre √† jour le statut du bot apr√®s un court d√©lai pour s'assurer que tout est configur√©
        console.log(`üìª Mise √† jour du statut apr√®s configuration de ${station.name}`);
        setTimeout(() => {
            updateBotStatus();
        }, 1000); // D√©lai de 1 seconde

        // Cr√©er l'embed de confirmation
        const embed = new EmbedBuilder()
            .setColor(station.color)
            .setTitle(`üìª **${station.name}** ${station.emoji}`)
            .setDescription(`üéµ **${station.description}**\n\n` +
                `üîä **Salon:** ${voiceChannel.name}\n` +
                `üéß **Qualit√©:** HD (128kbps)\n` +
                `üåê **Source:** ${station.url}\n` +
                `‚è∞ **D√©marr√©:** ${new Date().toLocaleTimeString('fr-FR')}`)
            .setThumbnail('https://cdn.discordapp.com/attachments/1234567890123456789/1234567890123456789/radio-icon.png')
            .setImage('https://cdn.discordapp.com/attachments/1234567890123456789/1234567890123456789/radio-playing.png');

        embed.setFooter({ 
            text: `üéß Radio Bot ‚Ä¢ ${station.name} ‚Ä¢ Streaming Live ‚Ä¢ ${new Date().toLocaleTimeString('fr-FR')}`,
            iconURL: 'https://cdn.discordapp.com/attachments/1234567890123456789/1234567890123456789/radio-icon.png'
        });

        // Importer les contr√¥les pour afficher seulement les boutons de contr√¥le
        const { createControlButtons } = require('./radio/controls');
        
        await interaction.editReply({
            embeds: [embed],
            components: [createControlButtons()]
        });

    } catch (error) {
        logger.error('Erreur lors du d√©marrage de la radio:', error);
        await interaction.editReply({
            content: '‚ùå Erreur lors du d√©marrage de la radio!'
        });
    }
}

// Fonction pour arr√™ter la radio
async function stopRadio(interaction) {
    if (!radioState.player) {
        return interaction.editReply({
            content: '‚ùå Aucune radio n\'est en cours de lecture!'
        });
    }

    try {
        radioState.player.stop();
        if (radioState.connection) {
            radioState.connection.destroy();
        }

        // R√©initialiser compl√®tement l'√©tat
        console.log('üìª R√©initialisation compl√®te de radioState');
        radioState.isLocked = false;
        radioState.currentStation = null;
        radioState.connection = null;
        radioState.player = null;
        radioState.lockedChannel = null;
        radioState.lockedBy = null;
        radioState.lockedAt = null;
        
        // Arr√™ter le tracking radio pour le leaderboard
        LeaderboardTracker.stopRadioMode();

        // Mettre √† jour le statut du bot imm√©diatement et apr√®s un d√©lai
        console.log('üìª Arr√™t de la radio - mise √† jour du statut');
        updateBotStatus();
        
        // Forcer une mise √† jour apr√®s un d√©lai pour s'assurer que radioState est bien r√©initialis√©
        setTimeout(() => {
            console.log('üìª Mise √† jour diff√©r√©e du statut apr√®s arr√™t radio');
            updateBotStatus();
        }, 2000);

        const embed = new EmbedBuilder()
            .setColor('#E74C3C')
            .setTitle('‚èπÔ∏è **RADIO ARR√äT√âE**')
            .setDescription('üîá **La radio a √©t√© arr√™t√©e avec succ√®s**\n\n' +
                `‚è∞ **Arr√™t√©:** ${new Date().toLocaleTimeString('fr-FR')}\n` +
                `üîì **Statut:** D√©verrouill√©`)
            .setThumbnail('https://cdn.discordapp.com/attachments/1234567890123456789/1234567890123456789/radio-stop.png');

        // Importer les contr√¥les pour afficher les boutons de navigation
        const { createControlButtons } = require('./radio/controls');
        
        await interaction.editReply({
            embeds: [embed],
            components: [createControlButtons()]
        });

        logger.success('üéµ Radio arr√™t√©e par l\'utilisateur');

    } catch (error) {
        logger.error('Erreur lors de l\'arr√™t de la radio:', error);
        await interaction.editReply({
            content: '‚ùå Erreur lors de l\'arr√™t de la radio!'
        });
    }
}

// Fonction pour verrouiller le bot
async function lockBot(interaction) {
    if (!radioState.player) {
        return interaction.editReply({
            content: '‚ùå Aucune radio n\'est en cours de lecture!'
        });
    }

    if (radioState.isLocked) {
        return interaction.editReply({
            content: 'üîí Le bot est d√©j√† verrouill√© dans ce salon vocal!'
        });
    }

    radioState.isLocked = true;
    radioState.lockedBy = interaction.user.id;
    radioState.lockedAt = Date.now();

    const embed = new EmbedBuilder()
        .setColor('#F39C12')
        .setTitle('üîí **BOT VERROUILL√â**')
        .setDescription(`üîê **Le bot est maintenant verrouill√© dans le salon vocal**\n\n` +
            `üìª **Station:** ${radioState.currentStation.name}\n` +
            `üéß **Salon:** ${radioState.lockedChannel.name}\n` +
            `üë§ **Verrouill√© par:** ${interaction.user.tag}\n` +
            `‚è∞ **Verrouill√©:** ${new Date().toLocaleTimeString('fr-FR')}\n\n` +
            `‚ö†Ô∏è **Seuls les administrateurs peuvent d√©verrouiller le bot**`)
        .setThumbnail('https://cdn.discordapp.com/attachments/1234567890123456789/1234567890123456789/lock-icon.png');

    // Importer les contr√¥les pour afficher les boutons de contr√¥le
    const { createControlButtons } = require('./radio/controls');
    
    await interaction.editReply({
        embeds: [embed],
        components: [createControlButtons()]
    });

    logger.success(`üîí Bot verrouill√© par ${interaction.user.tag} dans ${radioState.lockedChannel.name}`);
}

// Fonction pour d√©verrouiller le bot
async function unlockBot(interaction) {
    if (!radioState.isLocked) {
        return interaction.editReply({
            content: 'üîì Le bot n\'est pas verrouill√©!'
        });
    }

    // V√©rifier les permissions administrateur ou propri√©taire du bot
    const isAdmin = interaction.member.permissions.has(PermissionFlagsBits.Administrator);
    const isBotOwner = interaction.user.id === '1088121021044887572'; // .polosko
    
    if (!isAdmin && !isBotOwner) {
        return interaction.editReply({
            content: '‚ùå **Permission refus√©e**\n\nSeuls les administrateurs et le propri√©taire du bot peuvent d√©verrouiller le bot.'
        });
    }

    radioState.isLocked = false;
    radioState.lockedBy = null;
    radioState.lockedAt = null;

    const embed = new EmbedBuilder()
        .setColor('#27AE60')
        .setTitle('üîì **BOT D√âVERROUILL√â**')
        .setDescription(`üîì **Le bot a √©t√© d√©verrouill√© avec succ√®s**\n\n` +
            `üìª **Station:** ${radioState.currentStation.name}\n` +
            `üéß **Salon:** ${radioState.lockedChannel.name}\n` +
            `üë§ **D√©verrouill√© par:** ${interaction.user.tag}\n` +
            `‚è∞ **D√©verrouill√©:** ${new Date().toLocaleTimeString('fr-FR')}\n\n` +
            `‚úÖ **Le bot peut maintenant √™tre d√©plac√© librement**`)
        .setThumbnail('https://cdn.discordapp.com/attachments/1234567890123456789/1234567890123456789/unlock-icon.png');

    // Importer les contr√¥les pour afficher les boutons de contr√¥le
    const { createControlButtons } = require('./radio/controls');
    
    await interaction.editReply({
        embeds: [embed],
        components: [createControlButtons()]
    });

    logger.success(`üîì Bot d√©verrouill√© par ${interaction.user.tag}`);
}

// Fonction pour afficher le statut
async function showStatus(interaction) {
    const embed = new EmbedBuilder()
        .setColor(radioState.currentStation ? radioState.currentStation.color : '#95A5A6')
        .setTitle('üìä **STATUT RADIO**')
        .setDescription('üìª **Informations sur la radio actuelle**\n\n' +
            `üìª **Station:** ${radioState.currentStation ? radioState.currentStation.name : 'Aucune'}\n` +
            `üéß **Salon:** ${radioState.lockedChannel ? radioState.lockedChannel.name : 'Aucun'}\n` +
            `üîí **Verrouill√©:** ${radioState.isLocked ? 'Oui' : 'Non'}\n` +
            `üë§ **Verrouill√© par:** ${radioState.lockedBy ? `<@${radioState.lockedBy}>` : 'Personne'}\n` +
            `‚è∞ **Verrouill√© depuis:** ${radioState.lockedAt ? new Date(radioState.lockedAt).toLocaleTimeString('fr-FR') : 'N/A'}\n` +
            `üîä **Connexion:** ${radioState.connection ? 'Active' : 'Inactive'}\n` +
            `üéµ **Lecteur:** ${radioState.player ? 'Actif' : 'Inactif'}`)
        .setThumbnail('https://cdn.discordapp.com/attachments/1234567890123456789/1234567890123456789/status-icon.png');

    embed.setFooter({ 
        text: `üéß Radio Bot ‚Ä¢ Statut ‚Ä¢ ${new Date().toLocaleTimeString('fr-FR')}`,
        iconURL: 'https://cdn.discordapp.com/attachments/1234567890123456789/1234567890123456789/radio-icon.png'
    });

    // Importer les contr√¥les pour afficher les boutons de contr√¥le
    const { createControlButtons } = require('./radio/controls');
    
    await interaction.editReply({
        embeds: [embed],
        components: [createControlButtons()]
    });
}

module.exports = {
    data: new SlashCommandBuilder()
        .setName('radio')
        .setDescription('D√©marrer une station de radio dans un salon vocal (Administrateurs uniquement)')
        .addStringOption(option =>
            option.setName('station')
                .setDescription('Station de radio √† d√©marrer')
                .setRequired(false)
                .addChoices(
                    { name: 'üá´üá∑ France Inter', value: 'france-inter' },
                    { name: 'üéµ France Musique', value: 'france-musique' },
                    { name: 'üìö France Culture', value: 'france-culture' },
                    { name: 'üì∞ France Info', value: 'france-info' },
                    { name: 'üéß FIP', value: 'fip' },
                    { name: 'üé§ Mouv\'', value: 'mouv' },
                    { name: 'üé§ Skyrock', value: 'skyrock' },
                    { name: 'üåü Radio Nova', value: 'radio-nova' },
                    { name: 'üé∑ TSF Jazz', value: 'tsf-jazz' },
                    { name: 'üá∫üá∏ KEXP Seattle', value: 'kexp' },
                    { name: 'üåç Radio Paradise', value: 'radio-paradise' },
                    { name: 'üåô SomaFM Groove Salad', value: 'soma-fm' },
                    { name: 'üé∑ Jazz Radio', value: 'jazz-radio' }
                )),
    
    async execute(interaction) {
        try {
            // V√©rifier les permissions administrateur ou propri√©taire du bot
            const isAdmin = interaction.member.permissions.has(PermissionFlagsBits.Administrator);
            const isBotOwner = interaction.user.id === '1088121021044887572'; // .polosko
            
            if (!isAdmin && !isBotOwner) {
                return interaction.editReply({
                    content: '‚ùå **Permission refus√©e**\n\nSeuls les administrateurs et le propri√©taire du bot peuvent utiliser la commande `/radio`.'
                });
            }

            const stationId = interaction.options.getString('station');
            
            if (stationId) {
                // D√©marrer une station sp√©cifique
                await startRadioStation(interaction, stationId);
            } else {
                // Afficher le menu de navigation par pays
                const embed = createCountryNavigationEmbed();
                const buttons = createCountryNavigationButtons();
                
                // Ajouter les boutons de contr√¥le
                const { createControlButtons } = require('./radio/controls');
                buttons.push(createControlButtons());
                
                await interaction.editReply({
                    embeds: [embed],
                    components: buttons
                });
            }
        } catch (error) {
            logger.error('Erreur dans la commande /radio:', error);
            await interaction.editReply({
                content: '‚ùå Erreur lors de l\'ex√©cution de la commande radio!'
            });
        }
    },

    // Fonctions export√©es pour les interactions de boutons
    startRadioStation,
    stopRadio,
    lockBot,
    unlockBot,
    showStatus,
    createCountryNavigationEmbed,
    createCountryNavigationButtons,
    createCountryStationsEmbed,
    createCountryStationButtons,
    RADIO_STATIONS,
    RADIO_CATEGORIES,
    ALL_RADIO_STATIONS,
    radioState
};
